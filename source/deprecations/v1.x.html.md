---
title: Deprecations for v1.x
alias: guides/deprecations/
layout: deprecations
---

## Deprecations Added in Ember 1.x

What follows is a list of deprecations introduced to Ember.js during the 1.x
cycle.

For more information on deprecations in Ember, see the [main deprecations page]
(/deprecations).

### Deprecations Added in 1.7

#### Observing container views like arrays.

ContainerViews have been observable as arrays, where the items in
the array are childViews. This introduces complexity into container
views despite the feature being a rarely used one.

#### Ember.DeferredMixin and Ember.Deferred.

`Ember.DeferredMixin` and `Ember.Deferred` have been deprecated in favor
of using `RSVP.Promise`s.

#### `.then` on Ember.Application.

As part of the `Ember.DeferredMixin` deprecation, using `.then` on an
Ember.Application instance itself has been deprecated.

You can use the `ready` hook or initializers to defer/advance readiness
instead.

### Deprecations Added in 1.8

#### Global lookup of views

Previous to Ember 1.8, views would commonly be fetched from the global
scope:

```handlebars
{{view App.SomeView}}
{{each item in items itemViewClass=App.SomeView}}
```

Since Ember 1.8, views are more appropriately resolved on the application
via strings:

```handlebars
{{view "some"}}
{{each item in items itemViewClass="some"}}
```

They may also be fetched via a binding:

```handlebars
{{view view.someViewViaTheCurrentView}}
{{each itemViewClass=someViewViaAControllerProperty}}
```

In general, it is recommended that your Ember application avoid accessing
globals from a template.

##### New usage of Ember.Select

Most of Ember's provided views are already accessed via helpers. For example,
the [Ember.TextField](/api/classes/Ember.TextField.html) view is used via the
[input helper](/api/classes/Ember.Handlebars.helpers.html#method_input).

The [Ember.Select](/api/classes/Ember.Select.html) view has not been upgraded to
have a helper. Instead, it was suggested that you call it via the global
class name:

```handlebars
{{view Ember.Select content=manyItems}}
```

Since this lookup is now deprecated, the select view has been registered
on an application as `select`. The new usage is:

```handlebars
{{view "select" content=manyItems}}
```

See the updated [Ember.Select](/api/classes/Ember.Select.html) documentation
and the [built-in views guide](/guides/views/built-in-views) for more details
and examples.

##### Ember.js libraries and plugins

If the code triggering this deprecation is being fired from a library, that
library may need to update its suggested usage.

One solution for such a library is to provide mixins instead of classes:

```JavaScript
// usage is {{view "list"}}
var App.ListView = Ember.View.extend(ListView);
```

A more advanced solution is to use an initializer to register the plugin's
views on the the application:

```JavaScript
// usage is {{view "list"}}
Ember.Application.initializer({
  name: 'list-view',
  initialize: function(container, application) {
    container.register('view:list', ListView);
  }
});
```

More details on how to register an Ember.js framework component are available
in the [initializer API documentation](/api/classes/Ember.Application.html#toc_initializers)
and the [dependency injection guide](/guides/understanding-ember/dependency-injection-and-service-lookup).

#### Hash Location Paths Without Leading Slashes.

Prior to this release, if you were using `location: 'hash'` (which is the default), you were able to link to a route with a `location.hash` that didn't contain the expected leading forward slash. e.g. `#foo` instead of the correct `#/foo`. Very few, if any, should be impacted by this since the router always produces the correct form.

Doing so is ambiguous because you may also be trying to link to an element on the page who's id matches `<div id="foo">` and it also erroneously will create an extra history state if a user clicks on something that transitions to that route again, since it will change `location.hash === '#/foo'`.

This ability will be removed quickly to allow us to mimick the browser's behavior of scrolling the page to an element who's id matches, but in our case doing so after the transition ends and everything is rendered. Once this feature is added, you'll be able to link to id's even with doubled up hashes: `#/foo#some-id` as well as the expected `#some-id`.

### Deprecations Added in 1.9

#### More Consistent Handlebars Scope

In Ember 1.9, the `each` and `with` helpers come in two flavors: a "context-switching" flavor and a "named-parameter" flavor.

```handlebars
{{#each post in posts}}
  {{!-- the context in here is the same as the outside context,
        and `post` references the current iteration --}}
{{/each}}

{{#each posts}}
  {{!-- the context in here has shifted to the individual post.
        the outer context is no longer accessible --}}
{{/each}}

{{#with post as otherPost}}
  {{!-- the context in here is the same as the outside context }}
{{/with}}

{{#with post}}
  {{!-- the context in here has shifted to the post.
        the outer context is no longer accessible --}}
{{/with}}
```

This has proven to be one of the more confusing parts of the Ember templating system. It is also not clear to
beginners which to use, and when they choose the context-shifting form, they lose access to values in the outer
context that may be important.

Because the helper itself offers no clue about the context-shifting behavior, it is easy (even for more experienced
Ember developers) to get confused when skimming a template about which object a value refers to.

The context-shifting forms of `#each` and `#with` have been deprecated in favor of the named-parameter forms. In Ember 1.12, the `in` and `as` syntax are further deprecated in favor of block params syntax. See the [deprecation notes for in](/deprecations/v1.x/#toc_code-in-code-syntax-for-code-each-code) and [deprecation notes for as](/deprecations/v1.x/#toc_code-in-code-syntax-for-code-each-code).

##### Transition Plan

To transition your code to the new syntax, you can change templates that look like this:

```handlebars
{{#each people}}
  <p>{{firstName}} {{lastName}}</p>
  <p>{{address}}</p>
{{/each}}
```

with:

```handlebars
{{#each person in people}}
  <p>{{person.firstName}} {{person.lastName}}</p>
  <p>{{person.address}}</p>
{{/each}}
```

In preparation for further work on HTMLBars, the context switching form of `{{each}}` is deprecated. This is mostly a "mechanical" refactor and dramatically
simplifies how to think about the context in your templates. This change should be entirely mechanical.

In prior versions you may have done one of the following:

```handlebars
<ul>
  {{#each}}
    <li>{{name}}</li>
  {{/each}}
</ul>
```

```handlebars
<ul>
  {{#each people}}
    <li>{{name}}</li>
  {{/each}}
</ul>
```

You should now be using:

```handlebars
<ul>
  {{#each person in this}}
    <li>{{person.name}}</li>
  {{/each}}
</ul>
```

```handlebars
<ul>
  {{#each person in people}}
    <li>{{person.name}}</li>
  {{/each}}
</ul>
```

### Deprecations Added in 1.10

#### beforeObserver

Before observers are deprecated due to the negative performance implications they have for Ember internals and applications.

Typically they were used to have access to the old value of a property when it's about to change, but you can get same functionality in an even more efficient way with just a few lines of code:

```js
function fooObserver(obj){
  var newFoo = obj.get('foo');
  if (obj._oldFoo !== newFoo) {
    // do your stuff here
    obj._oldFoo = newFoo;
  }
}
addObserver(obj, 'foo', fooObserver);
fooObserver(obj); // Optionally call the observer immediately
```

### Deprecations Added in 1.11

#### ObjectController

Experienced Ember users have enjoyed the use of proxying behavior in
the `Ember.ObjectController` class since 1.0. However, this behavior
will be removed in Ember 2.0 as the framework migrates to routable components.

New users hit three roadbumps when learning about the object controller pattern.

* Given a certain model, which of the three controller options should I be using?
* Which controller is generated by the framework if I do not specify one?
* When using an object controller, why should the `this` context not be passed
  to actions if it has the properties of my model?

For these reasons, the [Road to Ember 2.0 RFC](https://github.com/emberjs/rfcs/pull/15)
listed object controllers as a concept to be removed from the framework.

To migrate from an explicitly defined object controller, first convert
the class definition to inherit from `Ember.Controller`. For example:

```
import Ember from "ember";

// Change:
export default Ember.ObjectController.extend({
// To:
export default Ember.Controller.extend({

// ...
```

Next update any use of `{{modelPropertyName}}` in templates with `{{model.modelPropertyName}}`.
You should also review any computed property dependent keys, observer keys, and `get` and `set`
statements on the route and controller. An example of how to make this migration can
be found [in this PR to the Ghost project](https://github.com/TryGhost/Ghost/pull/4748).

If a controller is not explicitly defined, but instead is being auto-generated
by the framework, it will only throw a deprecation message if the proxying
behavior is being used.

Added in [PR #10062](https://github.com/emberjs/ember.js/pull/10062).

#### Access to Instances in Initializers

Previously, initializers had access to an object that allowed them to
both register new classes and get instances of those classes.

If you have an initializer that gets instances of a class, you need to
change it to use an instance initializer.

Change code that looks like this:

```js
App.initializer({
  name: "clock",

  initialize: function(container, application) {
    application.register("clock:main", Clock);
    var clock = container.lookup("clock:main");
    clock.setStartTime(Date.now());
  }
});
```

To:

```js
App.initializer({
  name: "clock",

  initialize: function(registry, application) {
    application.register("clock:main", Clock);
  }
});

App.instanceInitializer({
  name: "clock",

  initialize: function(instance) {
    var clock = instance.container.lookup("clock:main");
    clock.setStartTime(Date.now());
  }
});
```

Added in [PR #10256](https://github.com/emberjs/ember.js/pull/10256).

### Warnings Added in 1.11

#### Binding Style Attributes

Content in Handlebars templates is automatically HTML-escaped to help
developers prevent inadvertently introducing cross-site scripting (XSS)
vulnerabilities into their applications.  If you want to display trusted
content as HTML, you can use a `SafeString`, a special string that tells Ember
that the content should be displayed without escaping.

While this works great for HTML, there are some cases where you may bind user
data that the browser interprets as CSS, not HTML. For example, you may bind
the `style` attribute of an element:

```handlebars
<div style={{myStyle}}></div>
```

Handlebars only escapes HTML, not CSS, so this may introduce a potential XSS
vulnerability into your application if a malicious user is able to provide data
used in the `myStyle` property.

Starting in Ember 1.11, you will receive a warning if you attempt to bind the
`style` attribute of an element. Once you have verified that the content being
displayed is trusted and properly escaped, you can disable the warning by
making the content a `SafeString`. For example:

```js
  myStyle: function() {
    var color = escapeCSS(this.get('color'));
    return ("color: " + color).htmlSafe();
  }.property('color')
```

You can learn more about `SafeString`s and writing code that prevents XSS
attacks by reading the [Writing
Helpers](http://emberjs.com/guides/templates/writing-helpers/) guide.

### Deprecations Added in 1.12

#### `in` syntax for `{{each}}`

The `in` syntax is used to name an iterated value with `{{each}}`. Block
params, introduced Ember 1.10, obsoletes the `in` syntax.

Each helpers should be udpated to use block params. For example this helper:

```handlebars
{{#each foo in bar}}
```

Can be converted as follows:

```handlebars
{{#each bar as |foo|}}
```

#### `as` sytnax for `{{with}}`

Renaming a value using `{{with}}` has been possible using the `as` syntax. Block params,
introduces in Ember 1.10, obsolete the `as` syntax.

With helpers should be updated to use block params. For example this helper:

```handlebars
{{#with foo as bar}}
```

Can be converted as follows:

```handlebars
{{#with foo as |bar|}}
```

#### Computed Properties With a Shared Getter And Setter

Ember.js 1.12 introduces an improved syntax for computed properties with
a setter. Previously, computed properties with a setter implemented that
setter by inspecting the number of arguments passed to the computed
property's descriptor.

For example, this computed property splits a full name into two
parts when set:

```js
  fullName: Ember.computed("firstName", "lastName", function(key, newName) {
    if (arguments.length > 1) {
      var parts = newName.split(" ");
      this.setProperties({ firstName: parts[0], lastName: parts[1] });
      return newName;
    } else {
      return this.get("firstName") + " " + this.get("lastName");
    }
  });
```

These uses should be converted to use the new discrete getter and setter
syntax introduced in 1.12:

```js
  fullName: Ember.computed("firstName", "lastName", {
    get: function() {
      return this.get("firstName") + " " + this.get("lastName");
    },
    set: function(key, newName) {
      var parts = newName.split(" ");
      this.setProperties({ firstName: parts[0], lastName: parts[1] });
      return newName;
    }
  });
```

For further reading, review the [RFC](https://github.com/emberjs/rfcs/blob/master/active/0001-improved-cp-syntax.md) describing this feature and the [pull request of the initial implementation](https://github.com/emberjs/ember.js/pull/9527).
